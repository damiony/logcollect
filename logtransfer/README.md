## `logtransfer`

日志中转站，对消息队列中的日志消息进行处理，然后将处理结果发给存储设备。

### 目录结构

```shell
.
├── README.md      
├── conf    # 配置文件管理
├── docs    # 配置文件
├── go.mod
├── go.sum
├── main.go  
├── mq  # 消息队列
├── saver   # 存储设备
├── services    # 主要逻辑目录
├── test    # 测试文件目录
└── utils   # 通用工具
```

- `services`：负责主要的逻辑，将消息从消息队列中取出来，然后再发给存储设备。
- `mq`: 消息队列消费者的相关实现，消息队列使用了`kafka`，也可以替换成其他工具，替换起来也很方便，代码修改量很少，只需要实现消费者的几个方法即可。
- `saver`: 存储设备的相关方法，代码中使用了`elasticsearch`，也可以替换成其他工具。
- `conf`: 配置文件管理，即使用了本地配置文件`.yml`，也使用了`etcd`进行配置中心化管理。

### 配置文件

本地配置文件存放的是`etcd`相关的配置，而`etcd`存放的则是日志消息相关配置。

`etcd`的`key`为`/logcollects/{本机ip}/logtransfer.json`，使用`etcdctl get /logcollects --prefix`命令即可看到配置列表。

`etcd`的`value`为:

```json
[
    {
        "title": "log",
        "mqhosts": ["10.1.3.95:9092"],
        "dbhosts": ["http://10.1.3.95:9200"]
    }
]
```

注意，上述`ip`需要替换成实际消息队列地址，以及实际存储设备地址。

可以根据日志的种类，在`json`列表中配置多个对象，最后存放在`etcd`中的是`json`字符串。

配置文件在服务启动时，会被加载一次。然后会一直监听`etcd`，一旦`etcd`有变化，就能对服务做实时更新。

### `kafka`

代码中的`kafka`使用的是消费者组模式，`go`语言的相关样例在网上很难找到，可以参考一下此处的写法。